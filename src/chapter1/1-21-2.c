/********************************************************************************
 *  主要收获
 *  写代码的两个预备动作，
 *      1. 抽象化要做的事情
 *      2. 把每个抽象出来的辅助变量和对象都落实成一个具体约定
 *      3. 然后严格遵守约定使用这些变量和对象
 *
 *******************************************************************************/
#include "mystd.h"

static const char TAB = '\t';
static const char ENTER = '\n';
static const char BLANK = ' ';

static const int TAB_SIZE = 8;

/**
  * 《答案书上的版本》
  * 思路：
  *     1. 每读到一个空格，先缓存起来
  *     2. 当光标到达制表符终止位，就把前面累计的空格换成一个制表符
  *     3. 当读到正常字符，就先把之前累计的所有空格和制表符先打出来，然后再打印当前读到的字符
  *     4. 但如果读到的是一个制表符，只打印前面累计的制表符。空格全部清空，然后再打印当前读到的制表符
  *     5. 如果读到的是回车符，光标位置归零
  */
int main(void) {
    int nb = 0;                 // 空格数
    int nt = 0;                 // TAB数
    int pos = 0;                // 光标

    char c;
    while ((c = getchar()) != EOF) {
        ++pos;                                              // 光标指向下一个写入位（当前为空）
        if (c == BLANK) {
            ++nb;                                           // 累计空格数
            if (pos % TAB_SIZE == 0) { nb = 0; ++nt; }      // 空格填够到制表符终止位，就换成一个制表符。空格清零
        } else {
            while (nt > 0) { putchar(TAB); --nt; }          // 打印正常字符前，先把累计的制表符和空格都打出来
            if (c != TAB) {                                 // 例外：如果是制表符，就不打所有空格
                while (nb > 0) { putchar(BLANK); --nb; }
            }
            putchar(c);                                     // 正常打印字符
            if (c == TAB) {
                nb = 0;                                     // 如果是制表符，清空所有空格
                pos = ((pos - 1) / TAB_SIZE + 1) * TAB_SIZE;// 制表符使得当前光标对齐到下一个制表符终止位（当然光标还要再往前跑一位）
            }
            if (c == ENTER) { pos = 0; }                    // 如果是回车符，光标归零
        }
    }
    // while (nt > 0) { putchar('t'); putchar(TAB); --nt; } // 本来应该打印末尾的空格和制表符。但putchar()函数本身不打印末尾的空格和制表符，所以不需要再打
    // while (nb > 0) { putchar('b'); --nb; }
}
